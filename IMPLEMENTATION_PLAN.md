# Flutter FFI Plugin for JoltPhysics

## Overview

Create a high-performance Flutter FFI plugin for JoltPhysics using modern 2025 Flutter practices. The architecture uses a **C-Shim** layer to bridge Jolt's C++ API with Dart FFI, **Build Hooks** (native_assets) for cross-platform compilation, and **ffigen** for automatic binding generation. The plugin supports Android, iOS, macOS, Windows, and Web (WASM).

## Checkpoint System

**Important**: This plan includes **8 checkpoints** between major implementation steps. At each checkpoint:

1. **Verify** - Test that the current step works correctly
2. **Commit** - Commit your work with a descriptive message
3. **Review** - Ensure everything is correct before proceeding

**Checkpoint List:**
- **CHECKPOINT 1**: After plugin initialization
- **CHECKPOINT 2**: After GitHub Actions workflow
- **CHECKPOINT 3**: After C-Shim implementation
- **CHECKPOINT 4**: After build hooks setup
- **CHECKPOINT 5**: After FFI bindings generation
- **CHECKPOINT 6**: After safe Dart API
- **CHECKPOINT 7**: After threading and WASM
- **CHECKPOINT 8**: Final verification before completion

**Workflow:**
1. Complete implementation step
2. Follow checkpoint verification steps
3. Commit your work
4. Only then proceed to next step

This ensures incremental progress with working commits at each stage.

## Architecture: The C-Shim Bridge

```
JoltPhysics Prebuilt Libraries (hosted on GitHub)
    ├── libjolt_android_arm64-v8a.a
    ├── libjolt_ios_arm64.a
    ├── libjolt_macos_arm64.a
    ├── libjolt_windows_x64.lib
    └── ... (downloaded by Build Hooks)
    ↓
C-Shim Layer (extern "C" functions, opaque pointers)
    ├── jolt_c.h (C-compatible header)
    └── jolt_c.cpp (C++ implementation wrapping Jolt)
    ↓
Native Libraries (built via Build Hooks, links against prebuilt Jolt)
    ├── libjolt_c.so (Android/Linux)
    ├── libjolt_c.dylib (iOS/macOS)
    ├── jolt_c.dll (Windows)
    └── jolt_c.wasm (Web)
    ↓
Dart FFI Bindings (auto-generated by ffigen)
    └── ffi_bindings.dart (Pointer<Void> for opaque handles)
    ↓
Safe Dart API (idiomatic Dart wrappers)
    ├── PhysicsSystem (manages world lifecycle)
    ├── BodyInterface (body operations)
    └── Shapes (sphere, box, capsule)
    ↓
Isolate Worker (off main thread)
    └── Physics simulation runs in separate isolate
    ↓
Flutter App / Newton Integration
```

**Key Architectural Decisions:**

1. **C-Shim Pattern**: Jolt's C++ cannot be directly accessed by Dart FFI. The C-Shim uses `extern "C"` to expose simple C functions with opaque pointers (`void*` handles).

2. **Build Hooks (native_assets)**: Replaces manual CMake/Podspec files. `hook/build.dart` handles cross-compilation automatically using `native_toolchain_c`.

3. **ffigen**: Automatically generates Dart FFI bindings from `jolt_c.h`, eliminating manual binding code.

4. **Opaque Pointers**: Jolt objects are represented as `Pointer<Void>` in Dart, maintaining type safety while hiding C++ complexity.

5. **Threading Strategy**: Physics simulation runs in a Worker Isolate to avoid blocking the UI thread. Jolt's `JobSystemThreadPool` is initialized with available CPU cores.

## Project Structure

```
.                               # Root directory (plugin created here)
├── pubspec.yaml                # Flutter package with native_assets config
├── README.md                   # Documentation
├── CHANGELOG.md                # Version history
├── lib/
│   ├── jolt_physics_ffi.dart   # Main library export
│   └── src/
│       ├── ffi_bindings.dart   # Auto-generated by ffigen (gitignored)
│       ├── native_library.dart # Native library loading (native_assets)
│       ├── safe/               # Safe Dart API wrappers
│       │   ├── physics_system.dart
│       │   ├── body_interface.dart
│       │   ├── shapes.dart
│       │   └── collision.dart
│       └── isolate/            # Isolate-based physics worker
│           └── physics_worker.dart
├── src/                        # C/C++ source code
│   ├── jolt_c.h                # C-Shim header (input for ffigen)
│   └── jolt_c.cpp              # C-Shim implementation (extern "C")
├── .dart_tool/
│   └── jolt_cache/             # Cached prebuilt libraries (gitignored)
├── hook/                       # Build Hooks (native_assets)
│   └── build.dart              # Cross-platform build script using native_toolchain_c
├── .github/
│   └── workflows/
│       └── build_jolt.yml      # GitHub Actions workflow for building JoltPhysics
├── web/
│   ├── jolt_c.wasm             # WASM module (built via Emscripten)
│   └── jolt_c.js               # WASM loader/glue code
├── android/                    # Android platform files (auto-generated)
├── ios/                        # iOS platform files (auto-generated)
├── macos/                      # macOS platform files (auto-generated)
├── windows/                    # Windows platform files (auto-generated)
├── linux/                      # Linux platform files (auto-generated)
└── example/                    # Example Flutter app
    └── lib/main.dart           # Demonstrates isolate-based physics
```

**Note**: Plugin is created in the root directory. No manual `CMakeLists.txt` or `podspec` files needed - Build Hooks handle everything automatically.

## Implementation Steps

### 1. Initialize Plugin with FFI Template

```bash
# In the root directory where you want the plugin
flutter create --template=plugin_ffi --platforms=android,ios,macos,windows,linux .
```

This creates the basic plugin structure in the current directory with native_assets support.

**Note**: Using `.` creates the plugin in the root directory instead of a subdirectory.

**CHECKPOINT 1 - Verify Plugin Setup:**

Before proceeding, verify and commit:

1. **Verify structure:**
   ```bash
   flutter pub get
   flutter analyze
   ```

2. **Check files created:**
   - `pubspec.yaml` exists
   - `lib/` directory with basic structure
   - Platform directories (android/, ios/, macos/, windows/, linux/)

3. **Commit:**
   ```bash
   git add .
   git commit -m "Initial plugin setup with FFI template"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 2. Create GitHub Actions Workflow (`.github/workflows/build_jolt.yml`)

Create a GitHub Actions workflow that automatically builds JoltPhysics for all platforms using matrix compilation. This workflow will:

1. Download the latest JoltPhysics source
2. Build for each platform/architecture in parallel
3. Upload artifacts to GitHub Releases **in the same repository** (not a separate repo)

**Workflow Structure:**

```yaml
name: Build JoltPhysics Prebuilt Libraries

on:
  workflow_dispatch:  # Manual trigger
  push:
    tags:
      - 'v*'  # Trigger on version tags
  schedule:
    - cron: '0 0 * * 0'  # Weekly build to get latest Jolt

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Android builds
          - os: ubuntu-latest
            platform: android
            arch: arm64-v8a
            abi: arm64-v8a
            toolchain: android-ndk
          - os: ubuntu-latest
            platform: android
            arch: armeabi-v7a
            abi: armeabi-v7a
            toolchain: android-ndk
          - os: ubuntu-latest
            platform: android
            arch: x86_64
            abi: x86_64
            toolchain: android-ndk
          
          # iOS builds (requires macOS)
          - os: macos-latest
            platform: ios
            arch: arm64
            sdk: iphoneos
          - os: macos-latest
            platform: ios
            arch: x86_64
            sdk: iphonesimulator
          
          # macOS builds
          - os: macos-latest
            platform: macos
            arch: arm64
            sdk: macosx
          - os: macos-latest
            platform: macos
            arch: x86_64
            sdk: macosx
          
          # Windows builds
          - os: windows-latest
            platform: windows
            arch: x64
            toolchain: msvc
          - os: windows-latest
            platform: windows
            arch: x86
            toolchain: msvc
          
          # WASM build (multithreaded)
          - os: ubuntu-latest
            platform: wasm
            arch: wasm32
            toolchain: emscripten
            multithreaded: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest JoltPhysics
        run: |
          git clone --depth 1 https://github.com/jrouwe/JoltPhysics.git jolt-source
          cd jolt-source
          git describe --tags > ../jolt_version.txt

      - name: Setup build environment
        # Platform-specific setup (NDK, Xcode, MSVC, Emscripten)
        ...

      - name: Build JoltPhysics
        run: |
          # Platform-specific build commands
          ...

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: libjolt_${{ matrix.platform }}_${{ matrix.arch }}
          path: build/libjolt.a  # or .lib, .wasm
          retention-days: 90

  create-release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            libjolt_*
            jolt_headers.zip
          tag_name: ${{ github.ref_name }}
          name: JoltPhysics Prebuilt Libraries ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Note**: The workflow automatically creates releases in **the same repository** where the workflow runs. No separate repository needed.

**Platform-Specific Build Steps:**

**Android:**

```yaml
- name: Setup Android NDK
  uses: android-actions/setup-android-ndk@v3
  with:
    ndk-version: '26.1.10909125'

- name: Build JoltPhysics for Android
  run: |
    cd jolt-source/Build
    cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
          -DANDROID_ABI=${{ matrix.abi }} \
          -DANDROID_PLATFORM=android-21 \
          -DCMAKE_BUILD_TYPE=Release \
          ..
    cmake --build . --config Release
    cp Jolt/libJolt.a ../../libjolt_android_${{ matrix.arch }}.a
```

**iOS:**

```yaml
- name: Build JoltPhysics for iOS
  run: |
    cd jolt-source/Build
    cmake -DCMAKE_SYSTEM_NAME=iOS \
          -DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }} \
          -DCMAKE_OSX_SYSROOT=${{ matrix.sdk }} \
          -DCMAKE_BUILD_TYPE=Release \
          ..
    cmake --build . --config Release
    cp Jolt/libJolt.a ../../libjolt_ios_${{ matrix.arch }}.a
```

**macOS:**

```yaml
- name: Build JoltPhysics for macOS
  run: |
    cd jolt-source/Build
    cmake -DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }} \
          -DCMAKE_BUILD_TYPE=Release \
          ..
    cmake --build . --config Release
    cp Jolt/libJolt.a ../../libjolt_macos_${{ matrix.arch }}.a
```

**Windows:**

```yaml
- name: Build JoltPhysics for Windows
  run: |
    cd jolt-source/Build
    cmake -G "Visual Studio 17 2022" -A x64 \
          -DCMAKE_BUILD_TYPE=Release \
          ..
    cmake --build . --config Release
    copy Jolt\Release\Jolt.lib ..\..\jolt_windows_${{ matrix.arch }}.lib
```

**WASM (Multithreaded):**

```yaml
- name: Setup Emscripten
  uses: mymindstorm/setup-emsdk@v14
  with:
    version: '3.1.45'

- name: Build JoltPhysics for WASM (multithreaded)
  run: |
    cd jolt-source/Build
    source $EMSDK/emsdk_env.sh
    emcmake cmake -DCMAKE_BUILD_TYPE=Release \
                  -DJOLT_BUILD_SAMPLES=OFF \
                  -DJOLT_BUILD_TESTS=OFF \
                  -DCMAKE_CXX_FLAGS="-pthread -sUSE_PTHREADS=1" \
                  ..
    emmake cmake --build . --config Release
    # Build WASM with pthread support
    emcc Jolt/libJolt.a -o jolt_c.wasm \
         -sUSE_PTHREADS=1 \
         -sPTHREAD_POOL_SIZE=4 \
         -sEXPORTED_FUNCTIONS='["_malloc","_free"]' \
         --no-entry
    cp jolt_c.wasm ../../jolt_c.wasm
```

**Jolt Headers:**

```yaml
- name: Package Jolt headers
  run: |
    cd jolt-source
    zip -r ../jolt_headers.zip Jolt/
```

**Key Features:**

- **Matrix Strategy**: Builds all platforms in parallel
- **Latest Jolt**: Downloads latest JoltPhysics on each run
- **Version Tracking**: Saves Jolt version to `jolt_version.txt`
- **Automatic Releases**: Creates GitHub Release on version tags
- **Artifact Retention**: Keeps artifacts for 90 days
- **WASM Multithreading**: Builds with pthread support for web workers

**Triggering the Workflow:**

- **Manual**: Use "Run workflow" button in GitHub Actions
- **On Tag**: Push a tag like `v1.0.0` to trigger release
- **Scheduled**: Weekly build to get latest JoltPhysics

**CHECKPOINT 2 - Verify GitHub Actions Workflow:**

Before proceeding, verify and commit:

1. **Verify workflow file:**
   - `.github/workflows/build_jolt.yml` exists
   - Matrix strategy includes all platforms
   - Build steps are correct

2. **Test workflow (optional but recommended):**
   - Push to GitHub
   - Go to Actions tab
   - Manually trigger workflow
   - Verify it runs (may fail if prebuilt libraries don't exist yet - that's OK)

3. **Commit:**
   ```bash
   git add .github/workflows/build_jolt.yml
   git commit -m "Add GitHub Actions workflow for building JoltPhysics"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 3. Create C-Shim Layer (`src/`)

Create minimal C-Shim API wrapping core JoltPhysics functionality. **Start small** - only wrap what's needed for particle physics.

**Core Functions (`jolt_c.h`):**

```c
// Opaque handles (void* in C, Pointer<Void> in Dart)
typedef void* JoltPhysicsSystem;
typedef void* JoltBodyInterface;
typedef void* JoltBodyID;
typedef void* JoltShape;

// Simple C structs for data exchange
typedef struct { float x, y, z; } JoltVec3;
typedef struct { float x, y, z, w; } JoltQuat;

// PhysicsSystem lifecycle
JoltPhysicsSystem jolt_physics_system_create(void);
void jolt_physics_system_destroy(JoltPhysicsSystem system);
void jolt_physics_system_step(JoltPhysicsSystem system, float delta_time, int collision_steps, int integration_sub_steps);

// BodyInterface operations
JoltBodyInterface jolt_physics_system_get_body_interface(JoltPhysicsSystem system);
JoltBodyID jolt_body_interface_create_body(JoltBodyInterface interface, JoltVec3 position, JoltQuat rotation, JoltShape shape, int motion_type);
void jolt_body_interface_add_body(JoltBodyInterface interface, JoltBodyID body_id, int activation_mode);
void jolt_body_interface_remove_body(JoltBodyInterface interface, JoltBodyID body_id);
JoltVec3 jolt_body_interface_get_position(JoltBodyInterface interface, JoltBodyID body_id);

// Shape creation
JoltShape jolt_shape_create_sphere(float radius);
JoltShape jolt_shape_create_box(JoltVec3 half_extent);
JoltShape jolt_shape_create_capsule(float half_height, float radius);

// Ray casting (for particle queries)
int jolt_physics_system_cast_ray(JoltPhysicsSystem system, JoltVec3 origin, JoltVec3 direction, JoltBodyID* out_body_id, JoltVec3* out_hit_point);
```

**Key Design Principles:**

- **Opaque Pointers**: All Jolt objects are `void*` handles. Dart sees them as `Pointer<Void>`.
- **Simple Structs**: Use plain C structs for Vec3, Quat, etc. (no C++ classes).
- **extern "C"**: All functions in `jolt_c.cpp` must be wrapped in `extern "C" { }`.
- **Error Handling**: Return error codes as integers, or use out parameters.
- **Minimal Surface**: Start with PhysicsSystem, BodyInterface, and basic Shapes only.

**CHECKPOINT 3 - Verify C-Shim Code:**

Before proceeding, verify and commit:

1. **Verify files created:**
   - `src/jolt_c.h` exists with C API definitions
   - `src/jolt_c.cpp` exists with implementation
   - Header includes proper extern "C" guards

2. **Test compilation (if Jolt headers available):**
   ```bash
   # If you have Jolt headers locally, test compile:
   g++ -c -I/path/to/jolt/headers src/jolt_c.cpp -o test.o
   ```

3. **Verify code quality:**
   - Check for proper error handling
   - Verify opaque pointer usage
   - Ensure C-compatible function signatures

4. **Commit:**
   ```bash
   git add src/jolt_c.h src/jolt_c.cpp
   git commit -m "Add C-Shim layer for JoltPhysics API"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 4. Build Hooks (`hook/build.dart`) - Download Prebuilt Libraries

**Important**: With the prebuilt approach, you do NOT need JoltPhysics source code as a submodule. You only need:

- Prebuilt JoltPhysics libraries (downloaded from GitHub)
- Jolt headers (for compiling the C-Shim - can be downloaded separately or included in release)

Create the build hook script that downloads prebuilt JoltPhysics libraries from your GitHub repository and builds only the C-Shim wrapper.

```dart
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:path/path.dart' as path;
import 'package:native_assets_cli/native_assets_cli.dart';
import 'package:native_toolchain_c/native_toolchain_c.dart';

// GitHub repository configuration - uses same repo as plugin
// The repository is determined from package name or can be configured
// For same repo: use 'owner/repo' from current repository
const String githubReleaseTag = 'v1.0.0'; // or 'latest'
// Base URL will be constructed from current repo context
// In practice, you can read from pubspec.yaml or git remote

void main(List<String> args) async {
  await build(args, (context, target) async {
    // 1. Download prebuilt JoltPhysics library for this platform
    final joltLib = await downloadPrebuiltJolt(context, target);
    
    // 2. Build C-Shim wrapper (links against prebuilt Jolt)
    final shimLib = await buildCShim(context, target, joltLib);
    
    return BuildOutput(
      assetId: 'jolt_c',
      linkMode: LinkMode.dynamic,
      file: shimLib,
    );
  });
}

Future<File> downloadPrebuiltJolt(BuildContext context, Target target) async {
  // Determine library filename based on platform
  final libName = _getLibraryName(target);
  
  // Get repository info from git remote or package config
  final repoInfo = await _getRepositoryInfo(context);
  final baseUrl = 'https://github.com/$repoInfo/releases/download/$githubReleaseTag';
  final url = '$baseUrl/$libName';
  
  // Cache directory for downloaded libraries
  final cacheDir = context.packageRoot.resolve('.dart_tool/jolt_cache');
  await cacheDir.create(recursive: true);
  
  final cachedFile = cacheDir.resolve(libName);
  
  // Check if already downloaded
  if (await cachedFile.exists()) {
    context.logger.info('Using cached library: $libName');
    return cachedFile;
  }
  
  // Download library
  context.logger.info('Downloading $libName from GitHub...');
  final response = await http.get(Uri.parse(url));
  
  if (response.statusCode != 200) {
    throw Exception('Failed to download $libName: ${response.statusCode}');
  }
  
  // Save to cache
  await cachedFile.writeAsBytes(response.bodyBytes);
  context.logger.info('Downloaded and cached: $libName');
  
  return cachedFile;
}

Future<String> _getRepositoryInfo(BuildContext context) async {
  // Try to get repo from git remote
  try {
    final result = await Process.run('git', ['remote', 'get-url', 'origin']);
    final url = result.stdout.toString().trim();
    // Extract owner/repo from git URL
    // Handles both https://github.com/owner/repo.git and git@github.com:owner/repo.git
    final match = RegExp(r'github\.com[:/]([\w-]+)/([\w-]+?)(?:\.git)?$').firstMatch(url);
    if (match != null) {
      return '${match.group(1)}/${match.group(2)}';
    }
  } catch (e) {
    // Fallback: use package name or environment variable
  }
  
  // Fallback: read from environment or config file
  // You can also set this in pubspec.yaml or a config file
  final envRepo = Platform.environment['JOLT_REPO'];
  if (envRepo != null) return envRepo;
  
  throw Exception('Could not determine repository. Set JOLT_REPO environment variable or ensure git remote is configured.');
}

Future<Directory> downloadJoltHeaders(BuildContext context) async {
  // Option 1: Download headers from GitHub release
  // Option 2: Include headers in a separate asset (jolt_headers.zip)
  // Option 3: Use a minimal header set that only includes what C-Shim needs
  
  final cacheDir = context.packageRoot.resolve('.dart_tool/jolt_cache');
  final headersDir = cacheDir.resolve('jolt_headers');
  
  if (await headersDir.exists()) {
    context.logger.info('Using cached Jolt headers');
    return headersDir;
  }
  
  // Download headers from GitHub release (same repo)
  context.logger.info('Downloading Jolt headers...');
  final repoInfo = await _getRepositoryInfo(context);
  final baseUrl = 'https://github.com/$repoInfo/releases/download/$githubReleaseTag';
  final headersUrl = '$baseUrl/jolt_headers.zip';
  final response = await http.get(Uri.parse(headersUrl));
  
  if (response.statusCode != 200) {
    throw Exception('Failed to download Jolt headers: ${response.statusCode}');
  }
  
  // Extract headers (you'll need package:archive for this)
  // For now, assume headers are in a zip file
  await headersDir.create(recursive: true);
  // TODO: Extract zip file to headersDir
  
  return headersDir;
}

String _getLibraryName(Target target) {
  final os = target.os.name;
  final arch = target.architecture.name;
  
  // Map to your GitHub release asset naming convention
  switch (os) {
    case 'android':
      return 'libjolt_android_$arch.a';
    case 'ios':
      return 'libjolt_ios_$arch.a';
    case 'macos':
      return 'libjolt_macos_$arch.a';
    case 'windows':
      return 'jolt_windows_$arch.lib';
    case 'linux':
      return 'libjolt_linux_$arch.a';
    default:
      throw UnsupportedError('Unsupported platform: $os');
  }
}

Future<File> buildCShim(BuildContext context, Target target, File joltLib) async {
  final cc = CCompiler(
    cc: Clang(),
    target: target,
  );
  
  final shimSource = context.packageRoot.resolve('src/jolt_c.cpp');
  final shimHeader = context.packageRoot.resolve('src/jolt_c.h');
  
  // Download Jolt headers if needed (or use cached headers)
  final joltHeaders = await downloadJoltHeaders(context);
  
  // Compile C-Shim wrapper
  final shimObj = await cc.compile(
    shimSource,
    includeDirectories: [
      context.packageRoot.resolve('src'),
      joltHeaders, // Jolt headers directory
    ],
  );
  
  // Link C-Shim with prebuilt Jolt library
  final linker = Linker(
    linker: cc.linker,
    target: target,
  );
  
  final shimLib = await linker.link(
    [shimObj],
    libraries: [joltLib],
    libraryDirectories: [joltLib.parent],
  );
  
  return shimLib;
}
```

**Where to Put Prebuilt Libraries:**

1. **In the Same GitHub Repository** (as Release Assets):
   - Prebuilt libraries are stored in **the same repository** as the FFI plugin
   - GitHub Actions workflow automatically builds and uploads to releases
   - Create GitHub Release (e.g., `v1.0.0`) - workflow does this automatically on tag push
   - Library files are uploaded as release assets with this naming:
     - `libjolt_android_arm64-v8a.a`
     - `libjolt_android_armeabi-v7a.a`
     - `libjolt_android_x86_64.a`
     - `libjolt_ios_arm64.a`
     - `libjolt_ios_x86_64.a`
     - `libjolt_macos_arm64.a`
     - `libjolt_macos_x86_64.a`
     - `jolt_windows_x64.lib`
     - `jolt_windows_x86.lib`
     - `libjolt_linux_arm64.a`
     - `libjolt_linux_x86_64.a`
     - `jolt_headers.zip` (optional - for Jolt headers)

2. **During Build** (automatic download):
   - Build hook downloads from: **the same repository's** releases
   - URL format: `https://github.com/<owner>/<repo>/releases/download/v1.0.0/libjolt_<platform>_<arch>.<ext>`
   - Repository is auto-detected from git remote
   - Libraries cached in: `.dart_tool/jolt_cache/` (gitignored)

3. **Local Cache** (after first build):
   - Location: `.dart_tool/jolt_cache/`
   - Contains: Downloaded libraries and headers
   - Delete to force re-download

**Build Hook Configuration:**

The build hook automatically detects the repository from git remote:
```dart
// Repository is auto-detected from git remote
// Or set JOLT_REPO environment variable if needed
const String githubReleaseTag = 'v1.0.0'; // or 'latest'
```

**Why No JoltPhysics Submodule:**

- ✅ Prebuilt libraries = compiled Jolt code (no source needed)
- ✅ C-Shim only needs headers (can download separately)
- ✅ Faster builds (no Jolt compilation)
- ✅ Consistent libraries (everyone gets same binaries)
- ✅ All in one repository (plugin + prebuilt libraries)

**Benefits:**

- Downloads prebuilt libraries automatically (no compilation time)
- Caches downloaded libraries in `.dart_tool/jolt_cache`
- Only builds the lightweight C-Shim wrapper
- Handles all platforms and architectures
- Easy to update: just tag a new release on GitHub
- All in one repository (plugin code + prebuilt libraries)
- No JoltPhysics source code needed
- Automatic repository detection from git remote

**CHECKPOINT 4 - Verify Build Hooks:**

Before proceeding, verify and commit:

1. **Verify build hook file:**
   - `hook/build.dart` exists
   - Download logic is implemented
   - Build logic links against prebuilt libraries

2. **Test build hook (if prebuilt libraries exist):**
   ```bash
   # Test that build hook can download and build
   dart run hook/build.dart
   ```

3. **Verify error handling:**
   - Check for proper error messages
   - Verify caching logic works

4. **Commit:**
   ```bash
   git add hook/build.dart
   git commit -m "Add build hooks for downloading prebuilt libraries"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 5. Configure ffigen (`pubspec.yaml`)

Add ffigen configuration to auto-generate Dart bindings. Since we're using prebuilt libraries, we only need the C-Shim header:

```yaml
ffigen:
  output: 'lib/src/ffi_bindings.dart'
  headers:
    entry-points:
      - 'src/jolt_c.h'
  compiler-opts:
    - '-Isrc'  # Only need C-Shim header, not Jolt source
```

Run `dart run ffigen` to generate `lib/src/ffi_bindings.dart`.

**Note**: If you need Jolt headers for type definitions, you can include them, but the prebuilt library approach means you don't need the full Jolt source.

**CHECKPOINT 5 - Verify FFI Bindings:**

Before proceeding, verify and commit:

1. **Generate bindings:**
   ```bash
   dart run ffigen
   ```

2. **Verify generated file:**
   - `lib/src/ffi_bindings.dart` exists
   - Contains function bindings from `jolt_c.h`
   - Opaque pointers are `Pointer<Void>`
   - Structs are properly defined

3. **Test compilation:**
   ```bash
   flutter analyze
   dart analyze lib/src/ffi_bindings.dart
   ```

4. **Commit:**
   ```bash
   git add pubspec.yaml lib/src/ffi_bindings.dart
   git commit -m "Configure ffigen and generate FFI bindings"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 6. Native Library Loading (`lib/src/native_library.dart`)

Use `native_assets` for automatic library loading:

```dart
import 'package:native_assets_cli/native_assets_cli.dart';

final DynamicLibrary _lib = loadNativeAsset('jolt_c') as DynamicLibrary;
```

No manual platform detection needed - `native_assets` handles it.

**After creating native_library.dart, verify:**

1. **Test library loading:**
   ```dart
   // Create a simple test
   import 'package:jolt_physics_ffi/src/native_library.dart';
   void main() {
     final lib = loadNativeLibrary();
     print('Library loaded: ${lib != null}');
   }
   ```

2. **Commit:**
   ```bash
   git add lib/src/native_library.dart
   git commit -m "Add native library loading with native_assets"
   ```

**✅ Continue to next step after verification.**

### 7. Dart FFI Bindings (`lib/src/ffi_bindings.dart`)

ffigen automatically generates bindings from `jolt_c.h`. The generated file will contain:

```dart
// Opaque pointer types
typedef JoltPhysicsSystem = Pointer<Void>;
typedef JoltBodyInterface = Pointer<Void>;
typedef JoltBodyID = Pointer<Void>;
typedef JoltShape = Pointer<Void>;

// Struct definitions
class JoltVec3 extends Struct {
  @Float()
  external double x;
  @Float()
  external double y;
  @Float()
  external double z;
}

// Function bindings
typedef jolt_physics_system_create_native_t = Pointer<Void> Function();
typedef jolt_physics_system_create_t = Pointer<Void> Function();
final jolt_physics_system_create = _lib.lookupFunction<
    jolt_physics_system_create_native_t,
    jolt_physics_system_create_t>('jolt_physics_system_create');
```

**Key Points:**

- Opaque handles become `Pointer<Void>` in Dart
- Structs are generated as `Struct` subclasses
- Function pointers are automatically typed

**Note**: FFI bindings are already verified in CHECKPOINT 5.

### 8. Safe Dart API (`lib/src/safe/`)

Create idiomatic Dart wrappers using `Pointer<Void>` for opaque handles:

```dart
class PhysicsSystem {
  final Pointer<Void> _handle;
  
  PhysicsSystem._(this._handle);
  
  factory PhysicsSystem.create() {
    final handle = jolt_physics_system_create();
    if (handle == nullptr) {
      throw Exception('Failed to create PhysicsSystem');
    }
    return PhysicsSystem._(handle);
  }
  
  void step(double deltaTime, {int collisionSteps = 1, int integrationSubSteps = 1}) {
    jolt_physics_system_step(_handle, deltaTime, collisionSteps, integrationSubSteps);
  }
  
  BodyInterface get bodyInterface {
    final handle = jolt_physics_system_get_body_interface(_handle);
    return BodyInterface._(handle);
  }
  
  void dispose() {
    jolt_physics_system_destroy(_handle);
  }
}
```

**Key Design:**

- RAII pattern: `dispose()` method for cleanup
- Factory constructors for creation
- Opaque handles stored as `Pointer<Void>`
- Error handling with Dart exceptions
- Type-safe wrappers around FFI functions

**CHECKPOINT 6 - Verify Safe Dart API:**

Before proceeding, verify and commit:

1. **Create basic test:**
   ```dart
   // test/safe_api_test.dart
   import 'package:jolt_physics_ffi/jolt_physics_ffi.dart';
   
   void main() {
     final system = PhysicsSystem.create();
     // Test basic operations
     system.dispose();
   }
   ```

2. **Run tests:**
   ```bash
   flutter test
   flutter analyze
   ```

3. **Verify memory management:**
   - Check that `dispose()` is called
   - Verify no memory leaks

4. **Commit:**
   ```bash
   git add lib/src/safe/
   git commit -m "Add safe Dart API wrappers for JoltPhysics"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 9. Threading & Performance (`lib/src/isolate/`)

**Critical**: Run physics simulation in a Worker Isolate to avoid blocking UI.

```dart
class PhysicsWorker {
  static Future<SendPort> spawn() async {
    final receivePort = ReceivePort();
    await Isolate.spawn(_isolateEntry, receivePort.sendPort);
    return await receivePort.first as SendPort;
  }
  
  static void _isolateEntry(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);
    
    final physicsSystem = PhysicsSystem.create();
    // Initialize Jolt's JobSystemThreadPool with CPU count
    final cpuCount = Platform.numberOfProcessors;
    // ... initialize Jolt threading ...
    
    receivePort.listen((message) {
      if (message is StepMessage) {
        physicsSystem.step(message.deltaTime);
        sendPort.send(StepCompleteMessage());
      }
    });
  }
}
```

**Performance Considerations:**

- Flutter 3.29+ runs Dart on platform thread (low FFI overhead)
- But physics simulation can still block UI if run synchronously
- Solution: Use Worker Isolate for physics, communicate via SendPort/ReceivePort
- Initialize Jolt's `JobSystemThreadPool` with `Platform.numberOfProcessors`

**CHECKPOINT 7 - Verify Threading and WASM:**

Before proceeding, verify and commit:

1. **Test isolate worker:**
   ```dart
   // Test that isolate spawns correctly
   final port = await PhysicsWorker.spawn();
   // Send test message
   ```

2. **Test WASM loading (if web support added):**
   - Verify `web/jolt_c.js` loads correctly
   - Test JavaScript interop

3. **Run tests:**
   ```bash
   flutter test
   ```

4. **Commit:**
   ```bash
   git add lib/src/isolate/ web/
   git commit -m "Add isolate-based physics worker and WASM support"
   ```

**✅ Only proceed to next step after successful verification and commit.**

### 10. Web Integration (`web/`)

For web, compile C-Shim to WASM using Emscripten, then use JavaScript interop:

```dart
@JS('JoltPhysics')
external class JoltPhysicsWasm {
  @JS('createPhysicsSystem')
  external int createPhysicsSystem();
  // ... mirror C-Shim API
}
```

**Note**: WASM integration is already verified in CHECKPOINT 7.

### 11. Prebuilt Library Integration (GitHub Releases)

**Important**: You do NOT need JoltPhysics source code as a submodule. The prebuilt approach only requires:

- Prebuilt JoltPhysics libraries (downloaded from GitHub)
- Jolt headers (for compiling C-Shim - can be downloaded separately)

**Where to Put Prebuilt Libraries:**

1. **In the Same GitHub Repository** (as Release Assets):
   - Prebuilt libraries are stored in **the same repository** as the FFI plugin
   - GitHub Actions workflow automatically builds and uploads to releases
   - Create GitHub Release (e.g., `v1.0.0`) - workflow does this automatically on tag push
   - Library files are uploaded as release assets with this naming:
     - `libjolt_android_arm64-v8a.a`
     - `libjolt_android_armeabi-v7a.a`
     - `libjolt_android_x86_64.a`
     - `libjolt_ios_arm64.a`
     - `libjolt_ios_x86_64.a`
     - `libjolt_macos_arm64.a`
     - `libjolt_macos_x86_64.a`
     - `jolt_windows_x64.lib`
     - `jolt_windows_x86.lib`
     - `libjolt_linux_arm64.a`
     - `libjolt_linux_x86_64.a`
     - `jolt_headers.zip` (optional - for Jolt headers)

2. **During Build** (automatic download):
   - Build hook downloads from: **the same repository's** releases
   - URL format: `https://github.com/<owner>/<repo>/releases/download/v1.0.0/libjolt_<platform>_<arch>.<ext>`
   - Repository is auto-detected from git remote
   - Libraries cached in: `.dart_tool/jolt_cache/` (gitignored)

3. **Local Cache** (after first build):
   - Location: `.dart_tool/jolt_cache/`
   - Contains: Downloaded libraries and headers
   - Delete to force re-download

**Build Hook Configuration:**

The build hook automatically detects the repository from git remote:
```dart
// Repository is auto-detected from git remote
// Or set JOLT_REPO environment variable if needed
const String githubReleaseTag = 'v1.0.0'; // or 'latest'
```

**Why No JoltPhysics Submodule:**

- ✅ Prebuilt libraries = compiled Jolt code (no source needed)
- ✅ C-Shim only needs headers (can download separately)
- ✅ Faster builds (no Jolt compilation)
- ✅ Consistent libraries (everyone gets same binaries)
- ✅ All in one repository (plugin + prebuilt libraries)

**Benefits:**

- Fast builds (no Jolt compilation)
- Consistent libraries across all users
- Easy updates (just tag new GitHub release)
- All in one repository (plugin code + prebuilt libraries)
- No JoltPhysics source code needed
- Automatic repository detection from git remote

## Key Files to Create

1. **[pubspec.yaml](pubspec.yaml)** - Flutter package with native_assets, ffigen config, and http dependency
2. **[.github/workflows/build_jolt.yml](.github/workflows/build_jolt.yml)** - GitHub Actions workflow for matrix building JoltPhysics for all platforms
3. **[hook/build.dart](hook/build.dart)** - Build Hooks script that downloads prebuilt libraries from GitHub and builds C-Shim
4. **[src/jolt_c.h](src/jolt_c.h)** - C-Shim header (input for ffigen)
5. **[src/jolt_c.cpp](src/jolt_c.cpp)** - C-Shim implementation (extern "C")
6. **[lib/jolt_physics_ffi.dart](lib/jolt_physics_ffi.dart)** - Main library export
7. **[lib/src/native_library.dart](lib/src/native_library.dart)** - Native library loading (native_assets)
8. **[lib/src/ffi_bindings.dart](lib/src/ffi_bindings.dart)** - Auto-generated by ffigen (gitignored)
9. **[lib/src/safe/physics_system.dart](lib/src/safe/physics_system.dart)** - Safe PhysicsSystem API
10. **[lib/src/safe/body_interface.dart](lib/src/safe/body_interface.dart)** - Safe BodyInterface API
11. **[lib/src/safe/shapes.dart](lib/src/safe/shapes.dart)** - Safe Shape API (sphere, box, capsule)
12. **[lib/src/isolate/physics_worker.dart](lib/src/isolate/physics_worker.dart)** - Isolate-based physics worker
13. **[web/jolt_c.js](web/jolt_c.js)** - WASM loader and JavaScript glue code
14. **[lib/src/web_bindings.dart](lib/src/web_bindings.dart)** - Web WASM bindings using JS interop
15. **[.dart_tool/jolt_cache/](.dart_tool/jolt_cache/)** - Cached prebuilt libraries (gitignored, created by build hook)

**Note**: No manual CMakeLists.txt, podspec, or build.gradle files needed - Build Hooks handle everything. Prebuilt libraries are downloaded from GitHub releases.

## Platform-Specific Considerations

**Note**: Build Hooks (`hook/build.dart`) handle all platform-specific compilation automatically. No manual configuration needed.

### Android

- **ABIs**: arm64-v8a, armeabi-v7a, x86_64 (handled automatically by Build Hooks)
- **Library Loading**: Automatic via `native_assets`
- **NDK**: Minimum API level 21 (Android 5.0) - set in Build Hooks
- **No Gradle/CMake**: Build Hooks handle everything

### iOS

- **Architectures**: arm64 (device), x86_64 (simulator), arm64-simulator (Apple Silicon)
- **Library Loading**: Automatic via `native_assets`
- **Deployment Target**: iOS 11.0+ - set in Build Hooks
- **No Podspec**: Build Hooks handle CocoaPods integration automatically

### macOS

- **Architectures**: arm64 (Apple Silicon), x86_64 (Intel)
- **Library Loading**: Automatic via `native_assets`
- **Deployment Target**: macOS 10.14+ - set in Build Hooks
- **Universal Binaries**: Build Hooks can create fat binaries automatically

### Windows

- **Architectures**: x64 (primary), x86 (optional)
- **Library Loading**: Automatic via `native_assets`
- **Build Tools**: Visual Studio 2019+ or MinGW (detected automatically)
- **C++ Runtime**: Linked automatically by Build Hooks

### Web (WASM)

- **Module Format**: WebAssembly (`.wasm`)
- **Build Tool**: Emscripten (configured in Build Hooks)
- **Loader**: JavaScript glue code (`jolt_c.js`)
- **Interop**: Use `dart:js_interop` for JavaScript function calls
- **Memory**: Manage WASM linear memory for data exchange
- **API Compatibility**: Mirror C-Shim API through JavaScript interop layer

## Minimal Feature Set

Focus on particle physics essentials:

- ✅ Rigid body creation and management
- ✅ Basic shapes (Sphere, Box, Capsule)
- ✅ Position/rotation queries and updates
- ✅ Ray casting (for particle queries)
- ✅ Shape casting (for collision detection)
- ✅ Body velocity and force application
- ❌ Constraints (not needed for basic particles)
- ❌ Motors (not needed for basic particles)
- ❌ Soft bodies (not needed for basic particles)

## Dependencies

**pubspec.yaml:**

```yaml
dependencies:
  ffi: ^2.0.0
  native_assets_cli: ^2.0.0
  http: ^1.0.0  # For downloading prebuilt libraries

dev_dependencies:
  ffigen: ^9.0.0
  native_toolchain_c: ^1.0.0

ffigen:
  output: 'lib/src/ffi_bindings.dart'
  headers:
    entry-points:
      - 'src/jolt_c.h'
  compiler-opts:
    - '-Isrc'
```

**Native:**

- Prebuilt JoltPhysics libraries (downloaded from GitHub releases)
- C++17 compiler (for building C-Shim only, handled by Build Hooks)
- **Web**: Emscripten (for building WASM, configured in Build Hooks)

**GitHub Repository:**

- Prebuilt libraries are stored in **the same repository** as the plugin
- Host as GitHub Release assets in the same repo
- Use consistent naming: `libjolt_<platform>_<arch>.<ext>`
- Repository is auto-detected from git remote (no manual configuration needed)
- Only need to set `githubReleaseTag` in `hook/build.dart` (or use 'latest')

## Integration with Newton

The plugin can be used in Newton particles library by:

1. Adding as dependency: `jolt_physics_ffi: ^1.0.0`
2. Importing: `import 'package:jolt_physics_ffi/jolt_physics_ffi.dart';`
3. Using safe API for particle-physics interactions

## Example Usage

```dart
import 'package:jolt_physics_ffi/jolt_physics_ffi.dart';

void main() async {
  // Spawn physics worker in isolate
  final physicsPort = await PhysicsWorker.spawn();
  
  // Create physics system in isolate
  physicsPort.send(CreatePhysicsSystemMessage());
  
  // Create body with sphere shape
  final shape = Shape.sphere(radius: 1.0);
  physicsPort.send(CreateBodyMessage(
    shape: shape,
    position: Vec3(0, 10, 0),
  ));
  
  // Step simulation (runs in isolate, doesn't block UI)
  physicsPort.send(StepMessage(deltaTime: 0.016));
  
  // Query position (async communication)
  physicsPort.send(GetPositionMessage(bodyId: bodyId));
}
```

**Key Points:**

- Physics runs in Worker Isolate (non-blocking)
- Communication via SendPort/ReceivePort
- UI thread remains responsive
- Jolt's JobSystemThreadPool handles multi-threading internally

## Final Checkpoint - Complete Verification

**CHECKPOINT 8 - Final Verification:**

Before considering the project complete:

1. **Test example app:**
   ```bash
   cd example
   flutter run
   # Test on multiple platforms if possible
   ```

2. **Run all tests:**
   ```bash
   flutter test
   flutter analyze
   ```

3. **Verify all platforms:**
   - Android: `flutter build apk --debug`
   - iOS: `flutter build ios --debug` (if on macOS)
   - macOS: `flutter build macos --debug`
   - Windows: `flutter build windows --debug`
   - Web: `flutter build web`

4. **Final commit:**
   ```bash
   git add example/
   git commit -m "Add example app demonstrating physics simulation"
   git tag v1.0.0  # Tag for release
   ```

5. **Create release:**
   - Push tag to trigger GitHub Actions
   - Verify prebuilt libraries are created
   - Test plugin with prebuilt libraries

**✅ Project complete after all verifications pass.**

